<!doctype html><html><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="chrome=1"><title>jsontl by DoublePrecisionSoftware</title><link rel="stylesheet" href="stylesheets/styles.css"><link rel="stylesheet" href="stylesheets/pygment_trac.css"><meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"><!--[if lt IE 9]> <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script> <![endif]--></head><body><div class="wrapper"><header><h1>jsontl</h1><p>Transform JSON with JSON</p><p class="view"><a href="https://github.com/DoublePrecisionSoftware/jsontl">View the Project on GitHub <small>DoublePrecisionSoftware/jsontl</small></a></p><ul><li><a href="https://github.com/DoublePrecisionSoftware/jsontl/zipball/master">Download <strong>ZIP File</strong></a></li><li><a href="https://github.com/DoublePrecisionSoftware/jsontl/tarball/master">Download <strong>TAR Ball</strong></a></li><li><a href="https://github.com/DoublePrecisionSoftware/jsontl">View On <strong>GitHub</strong></a></li></ul></header><section><h1 id="a-proposal-for-json-transforms">A Proposal for JSON Transforms</h1>
<p>As JSON is quickly becoming the standard for both over-the-wire and flat file
data, there has become a need for utilties for dealing with data of this type.</p>
<p>Many tools have been created: countless JSON parsing libraries, JSONPath,
JSONPatch, etc, but none so far have addressed the need for a fully featured
transformation language for JSON data.</p>
<p>Traditionally, XML has been the standard storage and transfer mechanism for
complex data, and thus it was necessary for XSLT to become a standard language
for transforming XML data into various permutaions for consumption outside its
originating source.  Such a mechanism has yet to be created for JSON, a format
that has been increasing in popularity in recent years.</p>
<h2 id="a-test-case">A Test Case</h2>
<p>One of the biggest changes to Microsoft&#39;s new ASP.NET 5 is the elimination of
the <code>web.config</code> for configuration of web applications.  This as been replaced
by a JSON formatted file, <code>config.json</code>.  This has many advantages, but
also one distincive disadvantage: the elimination of <code>web.config</code> Transforms.
ASP.NET has provided some flexibility in this area by providing overrides as
environment variables, but as the amount of configuration changes grows, this
may quickly become an unmanageable task.  JSONTL provides a much more flexible
option, and when applied correctly, can fully replace the whole of functionality
provided by the previous <code>web.config</code> Transorm approach.</p>
<h3 id="example">Example</h3>
<p>config.json</p>
<pre><code class="lang-json">{
    &quot;Data&quot;: {
        &quot;DefaultConnection&quot;: {
            &quot;ConnectionString&quot;: &quot;Server=DevServer...&quot;
        }
    }
}
</code></pre>
<p>production.jsontl</p>
<pre><code class="lang-json">{
    &quot;jsontl&quot;: {
        &quot;transform&quot;: {
            &quot;Data&quot;: [{
                &quot;in&quot;: {
                    &quot;DefaultConnection&quot;: [{
                        &quot;replace&quot;: {
                            &quot;ConnectionString&quot;: {
                                &quot;with&quot; : &#39;Server=ProductionServer...&#39;
                            }
                        }
                    }]
                }
            }]
        }
    }
}
</code></pre>
<p>Startup.cs</p>
<pre><code class="lang-cs">public Startup(IHostingEnvironment env) {
    Configuration = new Configruation()
        .AddJsonFile(string.Format(&quot;config.{0}.json&quot;, env.EnvironmentName));
}
</code></pre>
<p>gruntfile.js</p>
<pre><code class="lang-js">grunt.initConfig({
    jsontl: {
        staging: {
            files: {
                &#39;config.Staging.json&#39; : [&#39;config.json&#39;]
            },
            transform: &#39;staging.jsontl&#39;
        },
        production: {
            files: {
                &#39;config.Production.json&#39; : [&#39;config.json&#39;]
            },
            transform: &#39;production.jsontl&#39;
        }
    }
});

grunt.laodNpmTasks(&quot;grunt-jsontl&quot;);
</code></pre>
<p>The example above, when wired with <code>grunt-watch</code> or IDE tooling, can now perform
transforms automatically, in this case changing connection strings for the
necessary environments with no effort post-deployment.</p>
<h2 id="current-syntax">Current Syntax</h2>
<p>The syntax for JSONTL is designed to &quot;read&quot; naturally.</p>
<pre><code class="lang-json">{
    &quot;jsontl&quot;: {
        &quot;version&quot;, &quot;0.1&quot;,
        &quot;transform&quot;: {
            &quot;Data&quot;: [{
                &quot;replace&quot;: {
                    &quot;ConnectionString&quot;: {
                        &quot;with&quot; : &#39;Server=ProductionServer...&#39;
                    }
                }
            }]
        }
    }
}
</code></pre>
<p>Reading JSONTL syntax begins with the word &quot;in,&quot; and continues with each word
in the nested JSON syntax.  For example, the above transform will be read as:</p>
<blockquote>
<p>In Data, replace ConnectionString with &quot;Server=ProductionsServer...&quot;</p>
</blockquote>
<p>Since JSONTL files are actually JSON, the syntax is simple and familiar, with
some notable exceptions.  Operations, Locators, and certain other words (e.g.,
<code>in</code>, <code>replace</code>, <code>extend</code>, <code>when</code>, etc) are considered &quot;keywords&quot; and are reserved
for use by the JSONTL engine.</p>
<h3 id="transform-definitions">Transform Definitions</h3>
<p>A transform definition consists of a name of a property as an object key, with
an <code>Array</code> value containing a set of objects which can be any combination of
Operations and/or Locators.</p>
<h3 id="transform-locators">Transform Locators</h3>
<p>Currently, the only Locator is <code>in</code>, which tells
the JSONTL engine to look further into the object hierarcy, essentially further
nesting the &quot;context&quot; of the transform operations.  This enables transformation
of infinitely nested objects.</p>
<h3 id="transform-operations">Transform Operations</h3>
<p>JSONTL provides a few basic Operations to perform on data.  These include
<code>replace</code>, which replaces scalar values with the value specified by the <code>with</code>
parameter, and <code>extend</code>, which adds new key/value pairs to an object.</p>
<p>Many further Operations are planned, specifically around transforms pertaining
to <code>Array</code> types, such as <code>push</code>, <code>pop</code>, <code>slice</code>, etc.</p>
<h3 id="conditional-operations">Conditional Operations</h3>
<p>JSONTL also provides conditional logic for transform operations through the <code>when</code>
and <code>if</code> keywords.</p>
<pre><code class="lang-json">&quot;Person&quot;: [{
    &quot;replace&quot;: {
        &quot;FirstName&quot;: {
            &quot;with&quot;: &quot;Bob&quot;,
            &quot;when&quot;: {
                &quot;LastName&quot;: &quot;Smith&quot;
                &quot;MiddleInitial&quot;: &quot;X&quot;
            }
        }
    }
}]
</code></pre>
<p>This syntax tells the transformation engine to only perform the tranform operation
when the <code>Person</code> object being processed matches the criteria specified.  (e.g.,
the object has a <code>LastName</code> and <code>MiddleInitial</code> property that match the specified
values.)  The <code>if</code> keyword is similar, but checks if <em>any</em> of the criteria are met,
rather than <em>all</em> (<code>when</code> is an <code>AND</code>, <code>if</code> is an <code>OR</code>).</p>
<h4 id="pending-improvements">Pending Improvements</h4>
<p>I&#39;ve considered further extending the syntax of conditional operations for
more granular control.</p>
<pre><code class="lang-json">&quot;replace&quot;: {
    &quot;MaxItems&quot;: {
        &quot;with&quot;: 8,
        &quot;when&quot;: {
            &quot;CurrentItems&quot;: {
                &quot;gt&quot;: 4
            }
        }
    }
}
</code></pre>
<p>This syntax provides much more control, but can also get quite complex quite
quickly.</p>
<h3 id="destructive-transform">Destructive Transform</h3>
<p>Currently the transform process is destructive (that is, the data passed to the
transform operation is modified during the trandformation process).  Efforts to
perform a non-destructive transform have been considered, but not yet implemented.</p>
<h2 id="futher-development">Futher Development</h2>
<p>As of the time of this writing, conditionals for transform operations only have
access to the properties within the current transformation context.  I have
considered implementing &quot;parent&quot; and &quot;root&quot; locators in order to allow for more
flexible conditions, but have not yet pursued development in that area.</p>
<p>The <code>version</code> property of the transform file is currently not used, but is
recommended for future validation in case the API changes such that tranformation
engines need to ensure compatability.</p>
</section><footer><p>This project is maintained by <a href="https://github.com/DoublePrecisionSoftware">DoublePrecisionSoftware</a></p><p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p></footer></div><script src="javascripts/scale.fix.js"></script><script type="text/javascript">var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));</script><script type="text/javascript">try {var pageTracker = _gat._getTracker("UA-46742736-2");pageTracker._trackPageview();} catch (err) {}</script></body></html>
